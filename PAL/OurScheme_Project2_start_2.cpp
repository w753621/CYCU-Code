# include <stdlib.h>
# include <stdio.h>
# include <string>
# include <vector>
# include <stack>
# include <queue>
# include <iomanip>  // 控制輸出小數位數
# include <iostream>
using namespace std;
static int utestNum = -1;

struct TokenData {  // token字串、token的類別。
  int token_line;
  int token_column;
  string token_name;
  string token_type;
}; // TokenData

struct TreeNode {
  TokenData token_data;
  bool isStart;
  bool isEnd;
  TreeNode * left;
  TreeNode * right;
}; // TreeNode

struct LPforRP {
  int real_num;    // 每一個都要插入.nil
}; // LPforRP

struct SystemSymbol {
  string symbol_name;
  string symbol_type;
}; // SystemSymbol

struct StringErrorInfo {
  int line;
  int column;
}; // StringErrorInfo

struct NoAtomQuoteErrorInfo {
  string token_name;
  int line;
  int column;
}; // NoAtomQuoteErrorInfo

struct NoRightParenErrorInfo {
  string token_name;
  int line;
  int column;
}; // NoRightParenErrorInfo

struct DefineTable {
  string define_name;
  TreeNode * define_value;
}; // DefineTable

struct SaveFunctionParameter {
  string fun_Name;
  string fun_Type;
  int fun_Pos;
  int argument_Num;         // 計算該function層有幾個參數(包含可能是Function)。
  queue<int> parameter_Pos; // 計算參數時所存的參數。
  TreeNode * result_Node;   // 存該層的參數。
}; // SaveFunctionParameter

struct UnboundSymbolErrorInfo {
  string symbol_name;
}; // UnboundSymbolErrorInfo

struct NonFunctionErrorInfo {
  TreeNode * nonfun_name;
}; // NonFunctionErrorInfo

struct AgumentNumberErrorInfo {
  string fun_name;
}; // AgumentNumberErrorInfo

// 接下存的是本身文法不合法的
struct NonListErrorInfo {
  TreeNode * nonlist_node;
}; // NonListErrorInfo

struct FormatErrorInfo {
  string format_fun_name;
  TreeNode * format_error_node;
}; // FormatErrorInfo

struct LevelErrorInfo {
  string level_function_name;
}; // LevelErrorInfo

struct ProcedureErrorInfo {
  string procedure_error_name;
}; // ProcedureErrorInfo

struct ArgumentTypeErrorInfo {
  string function_name;
  string argumentype_error_name;
}; // ArgumentTypeErrorInfo


vector<DefineTable> gDefineTable;

class Scanner {         // 只負責切出GetToken()，跟PeekToken()，並回傳該Token字串。
  private:
  int mscan_line, mscan_column;
  void ASeparatorType( char sexpchar, TokenData & token_data ) {
    if ( sexpchar == '(' ) {
      if ( cin.peek() == ')' ) {                    //  case1:() 偷看下一個字元，如果是')'就讀入，並把此token類別改成"NIL"。
        char sexpchar = '\0';
        cin.get( sexpchar );
        TraceTokenLineColumn( sexpchar );
        token_data.token_name = "nil";
        token_data.token_type = "NIL";
      } // if
      //  case2: ( ) LEFT-PAREN RIGHT-PAREN
      else if ( cin.peek() == ' ' || cin.peek() == '\n' || cin.peek() == '\t' ) {
        char sexpchar = '\0';
        cin.get( sexpchar );
        TraceTokenLineColumn( sexpchar );
        bool finished = false;
        while ( ( sexpchar == ' ' || sexpchar == '\n' || sexpchar == '\t' ) && !finished ) {
          if ( cin.peek() == ' ' || cin.peek() == '\n' || cin.peek() == '\t' ) {
            cin.get( sexpchar );
            TraceTokenLineColumn( sexpchar );
          } // if
          else if ( cin.peek() == ')' ) {
            cin.get( sexpchar );
            finished = true;
            TraceTokenLineColumn( sexpchar );
            token_data.token_name = "nil";
            token_data.token_type = "NIL";
          } // else if
          else {
            finished = true;
            token_data.token_name = "(";                   // case3: ( LEFT-PAREN
            token_data.token_type = "LEFT-PAREN";
          } // else

        } // while

      } // else if
      else {
        token_data.token_name = "(";                   // case3: ( LEFT-PAREN
        token_data.token_type = "LEFT-PAREN";
      } // else

    } // if
    else if ( sexpchar == ')' ) {
      token_data.token_name = ")";
      token_data.token_type = "RIGHT-PAREN";
    }  // else if
    else if ( sexpchar == '\'' ) {
      token_data.token_name = "'";
      token_data.token_type = "QUOTE";
    } // else if
    else if ( sexpchar == ';' ) {                            // 這是註解，利用ReadCommentLine()讀掉，並記錄當前scan行列。
      token_data.token_name = ";";
      token_data.token_type = "COMMENT";
      ReadCommentLine();
      mCommentLine++;
    } // else if
    else if ( sexpchar == '\"' ) {                           // 這是string，小心5種case(wait deal)
      string aString = "";
      aString = aString + sexpchar;
      if ( IsString( aString ) ) {
        token_data.token_name = aString;
        token_data.token_type = "STRING";
      } // if
      else {
        // IsString()如果false會直接throw一個StringErrorInfo回main()中。
      } // else

    } // else if
  } // ASeparatorType()

  // IsString()會判斷string的文法，"之後的到line-eneter之前要有"，沒的話就throw StringErrorInfo，
  bool IsString( string & aString ) {
    bool result = false;                    // 並把後面到line-enter前全部讀掉。
    StringErrorInfo aStringErrorInfo;
    char sexpchar = '\0';
    if ( cin.peek() == '\n' ) {             // 下一個即是換行字元gg，不是quote，直接把後面的資料也給讀掉(不需要)。
      cin.get( sexpchar );
      aStringErrorInfo.column = mscan_column + 1;
      aStringErrorInfo.line = mscan_line;
      TraceTokenLineColumn( sexpchar );
      ReadErrorLine();
      throw aStringErrorInfo;
    } // if

    if ( cin.peek() != EOF ) cin.get( sexpchar );
    TraceTokenLineColumn( sexpchar );
    bool finished = false;
    while ( sexpchar != '\n' && !finished ) {
      if ( sexpchar == '\"' ) {                   // 遇到"直接結束完成
        aString = aString + sexpchar;
        result = true;
        finished = true;
      } // if
      else if ( sexpchar == '\\' ) {            // 遇到分號字元，考慮後一個字元後是不是n、t、"、\這四種情況，是的話做適當處理，不是的話就是普通的分號字元。
        if ( cin.peek() == 'n' ) {
          cin.get( sexpchar );
          aString = aString + "\n";
          mscan_column = mscan_column + 1;
        } // if
        else if ( cin.peek() == 't' ) {
          cin.get( sexpchar );
          aString = aString + "\t";
          mscan_column = mscan_column + 1;
        } // else if
        else if ( cin.peek() == '\"' ) {
          cin.get( sexpchar );
          aString = aString + "\"";
          mscan_column = mscan_column + 1;
        } // else if
        else if ( cin.peek() == '\\' ) {
          cin.get( sexpchar );
          aString = aString + "\\";
          mscan_column = mscan_column + 1;
        } // else if
        else {                                // 分號本身他就只是一個普通的字元而已
          aString = aString + sexpchar;
        } // else

      } // else if
      else {
        aString = aString + sexpchar;
      } // else

      if ( !finished ) {
        if ( cin.peek() != EOF ) cin.get( sexpchar );
        if ( sexpchar == '\n' || cin.peek() == EOF ) {
          aStringErrorInfo.column = mscan_column + 1;
          aStringErrorInfo.line = mscan_line;
          if ( cin.peek() != EOF ) TraceTokenLineColumn( sexpchar );
          if ( cin.peek() != EOF ) ReadErrorLine();
          throw aStringErrorInfo;
        } // if
        else {
          TraceTokenLineColumn( sexpchar );
        } // else
      } // if
    } // while 

    return result;
  } // IsString()

  bool IsDOT( string token, TokenData & token_data ) {
    bool result = false;
    if ( token == "." ) {
      token_data.token_name = token;
      token_data.token_type = "DOT";
      result = true;
    } // if

    return result;
  } // IsDOT()

  bool IsINT( string token, TokenData & token_data ) {
    string intstring = "";
    bool result = false;
    int i = 0, number = 0;
    if ( token[0] == '+' || token[0] == '-' ) {           // '+'、'-'、'數字'三種情況。
      if ( token[0] == '-' ) intstring = intstring + '-';
      i++;
    } // if

    bool finished = false;
    while ( token[i] && !finished ) {
      number = token[i];
      if ( number >= 48 && number <= 57 ) {
        intstring = intstring + token[i];
        result = true;
      } // if
      else {
        result = false;
        finished = true;
      } // else if

      i++;
    } // while

    if ( result ) {
      token_data.token_name = intstring;
      token_data.token_type = "INT";
    } // if

    return result;
  } // IsINT()

  bool IsFLOAT( string token, TokenData & token_data ) {
    string floatstring = "";
    bool result = false, hasDotOnce = false;
    int i = 0, number = 0;
    // case1:.開頭 case2:+、-開頭 case3:+、-開頭第二字元為點
    if ( token[0] == '+' || token[0] == '-' || token[0] == '.' ) {
      if ( token[0] == '.' ) {
        floatstring = floatstring + "0.";
        hasDotOnce = true;
        i++;
      } // if
      else {
        if ( token[0] == '-' ) {
          floatstring = floatstring + "-";
          i++;
        } // if
        else if ( token[0] == '+' ) {
          i++;
        } // else if

        if ( token[1] == '.' ) {
          floatstring = floatstring + "0.";
          hasDotOnce = true;
          i++;
        } // if

      } // else

    } // if

    bool finished = false;
    while ( token[i] && !finished ) {
      number = token[i];
      if ( ( number >= 48 && number <= 57 ) ) {
        floatstring = floatstring + token[i];
        result = true;
      } // if
      else if ( ( token[i] == '.' ) && ( !hasDotOnce ) ) {
        floatstring = floatstring + token[i];
        result = true;
        hasDotOnce = true;
      } // else if
      else {
        hasDotOnce = false;
        result = false;
        finished = true;
      } // else

      i++;
    } // while

    if ( result && hasDotOnce ) {
      token_data.token_name = floatstring;
      token_data.token_type = "FLOAT";
    } // if

    return result;
  } // IsFLOAT()

  bool IsT( string token, TokenData & token_data ) {
    string tstring = "";
    bool result = false;
    if ( token == "t" || token == "#t" ) {
      tstring = "#t";
      result = true;
    } // if

    if ( result ) {
      token_data.token_name = tstring;
      token_data.token_type = "T";
    } // if

    return result;
  } // IsT()

  bool IsNIL( string token, TokenData & token_data ) {
    string nilstring = "";
    bool result = false;
    if ( token == "nil" || token == "#f" ) {
      nilstring = "nil";
      result = true;
    } // if

    if ( result ) {
      token_data.token_name = nilstring;
      token_data.token_type = "NIL";
    } // if

    return result;
  } // IsNIL()

  void TraceTokenLineColumn( char sexpchar ) {
    if ( sexpchar == '\n' ) {
      mscan_line++;
      mscan_column = 0;
    } // if
    else if ( sexpchar == '\t' ) {
      mscan_column = mscan_column + 8;
    } // else if
    else {
      mscan_column++;
    } // else

  } // TraceTokenLineColumn()

  public:
  int mCommentLine;
  Scanner( int lastspace ) {
    mscan_line = 1;
    mscan_column = lastspace;
    mCommentLine = 0;
  } // Scanner()

  TokenData GetOneToken() {         // 抓下一個token
    char sexpchar = '\0';
    if ( cin.peek() == EOF ) {                                // 先確定一開始讀的不是EOF
      throw -1;
    } // if

    // 使用一個字元下去讀，(一) 先跳過所有white space直到EOF或非White space
    TokenData token_data;
    cin.get( sexpchar );
    TraceTokenLineColumn( sexpchar );
    while ( sexpchar == '\n' || sexpchar == ' ' || sexpchar == '\t' ) {
      if ( cin.peek() == EOF ) {
        throw -1;
      } // if
      cin.get( sexpchar );
      TraceTokenLineColumn( sexpchar );
    } // while

    token_data.token_column = mscan_column;
    token_data.token_line = mscan_line;
    // 這時候拿到的sexpchar是「非white space」，可能是「separator」或「非separator」，separator字元也
    // 非separator，處理到white space(一個token) or separator(兩個token)
    // 此token可能是1.INT、2.STRING(")、3.DOT(.)、4.FLOAT、5.NIL(nil、#f、())、6.T(t、#t)、QUOTE、SYMBOL
    if ( sexpchar == '(' || sexpchar == ')' || sexpchar == '\'' || sexpchar == '\"' || sexpchar == ';' ) {
      ASeparatorType( sexpchar, token_data );
      return token_data;
    } // if
    else {
      string token = "";
      token = token + sexpchar;
      bool finished = false;
      while ( ( sexpchar != '\n' || sexpchar != ' ' || sexpchar != '\t' ) && !finished ) {
        // 預測下個字元如果是separator或white space，停止讀入，並處理到separator之前。
        char nextoken_char = '\0';
        nextoken_char = cin.peek();
        if ( ( nextoken_char == '\'' || nextoken_char == '\"' || nextoken_char == ';'
               || nextoken_char == '(' || nextoken_char == ')' || nextoken_char == EOF ) && !finished ) {
          if ( IsDOT( token, token_data ) ) ;
          else if ( IsINT( token, token_data ) ) ;
          else if ( IsFLOAT( token, token_data ) ) ;
          else if ( IsT( token, token_data ) ) ;
          else if ( IsNIL( token, token_data ) ) ;
          else {
            token_data.token_name = token;
            token_data.token_type = "SYMBOL";
          } // else

          finished = true;
        } // if

        if ( ( nextoken_char == '\n' || nextoken_char == ' ' || nextoken_char == '\t' ) && !finished ) {
          if ( IsDOT( token, token_data ) ) ;
          else if ( IsINT( token, token_data ) ) ;
          else if ( IsFLOAT( token, token_data ) ) ;
          else if ( IsT( token, token_data ) ) ;
          else if ( IsNIL( token, token_data ) ) ;
          else {
            token_data.token_name = token;
            token_data.token_type = "SYMBOL";
          } // else

          finished = true;
        } // if
        else if ( !finished ) { // 繼續此Token之探索。
          cin.get( sexpchar );
          token = token + sexpchar;
          TraceTokenLineColumn( sexpchar );
        } // else if

      } // while

    } // else

    return token_data;
  } // GetOneToken()

  TokenData PeekToken() {           // Parser預先知道下一個token的function，好判斷文法走向。
    // 而在GetNextTokenForParser()中，必須把lookahead改成true，才不會又讀了一個新的token進來。
    TokenData token_data;
    token_data = GetOneToken();
    while ( token_data.token_type == "COMMENT" ) {
      token_data = GetOneToken();
    } // while

    return token_data;
  } // PeekToken()

  void ReadErrorLine() {
    char getnext = '\0';
    if ( mscan_column != 0 ) {
      if ( cin.peek() == EOF ) return;
      cin.get( getnext );
      while ( getnext != '\n' ) {
        if ( cin.peek() == EOF ) return;
        cin.get( getnext );
      } // while

    } // if
  } // ReadErrorLine()

  int ReadEndLine() {
    char getnext = '\0';
    int i = 0;
    while ( cin.peek() == ' ' || cin.peek() == ';' ) {
      cin.get( getnext );
      if ( cin.peek() == EOF ) return 0;
      i++;
      if ( getnext == ';' ) {
        ReadCommentLine();
        return 0;
      } // if

    } // while

    if ( cin.peek() == '\n' ) {
      cin.get( getnext );
      i = 0;
    } // if

    return i;
  } // ReadEndLine()

  void ReadCommentLine() {
    char getnext = '\0';
    if ( mscan_column != 0 ) {
      if ( cin.peek() == EOF ) return;
      cin.get( getnext );
      TraceTokenLineColumn( getnext );
      while ( getnext != '\n' ) {
        if ( cin.peek() == EOF ) return;
        cin.get( getnext );
        TraceTokenLineColumn( getnext );
      } // while

    } // if
  } // ReadCommentLine()

}; // Scanner

class Parser {
  private:
  vector<TokenData> mAccurate_token_vector;
  vector<TokenData> mTranslated_token_vector;
  bool mlookahead;                                     // 掌管GetOneToken時的準則
  public:
  TokenData maPeekToken;
  Parser() {
    mlookahead = false;
  } // Parser()

  TokenData GetNextTokenForParser( Scanner & aScanner ) {      // 回傳這次Getoken
    TokenData get_token_data;
    if ( mlookahead ) {    // GetToken時，確定lookahead要是false的情況下才可以往下getoken，否則端出已讀做好處理的token進去parser
      get_token_data = maPeekToken;
      mlookahead = false;
    } // if
    else {
      get_token_data = aScanner.GetOneToken();
      while ( get_token_data.token_type == "COMMENT" ) {
        get_token_data = aScanner.GetOneToken();
      } // while

    } // else

    mAccurate_token_vector.push_back( get_token_data );
    return get_token_data;
  } // GetNextTokenForParser()

  bool IsSexp( TokenData & token_IsSexp, Scanner & aScanner ) {
    token_IsSexp = GetNextTokenForParser( aScanner );
    if ( IsAtom( token_IsSexp ) ) {                 // <ATOM>
      return true;
    } // if
    else if ( token_IsSexp.token_type == "LEFT-PAREN" ) {
      // LEFT-PAREN <S-exp> { <S-exp> } [ DOT <S-exp> ] RIGHT-PAREN
      if ( IsSexp( token_IsSexp, aScanner ) ) {
        // <S-exp> { <S-exp> } [ DOT <S-exp> ] RIGHT-PAREN 往下繼續做
      } // if
      else {
        NoAtomQuoteErrorInfo aNoAtomQuoteErrorInfo;        // return NoAtomQuoteErrorInfo
        aNoAtomQuoteErrorInfo.token_name = token_IsSexp.token_name;
        aNoAtomQuoteErrorInfo.column = token_IsSexp.token_column;
        aNoAtomQuoteErrorInfo.line = token_IsSexp.token_line - aScanner.mCommentLine;
        aScanner.ReadErrorLine();
        throw aNoAtomQuoteErrorInfo;
      } // else

      token_IsSexp = aScanner.PeekToken();    // 偷看下一個Token { <S-exp> } [ DOT <S-exp> ] RIGHT-PAREN
      maPeekToken = token_IsSexp;              // 設定aPeekToken
      mlookahead = true;
      if ( token_IsSexp.token_type != "RIGHT-PAREN" && token_IsSexp.token_type != "DOT" ) {
        bool loop = true;
        while ( loop ) {    // { <S-exp> }
          if ( IsSexp( token_IsSexp, aScanner ) ) {
            token_IsSexp = aScanner.PeekToken();
            maPeekToken = token_IsSexp;
            mlookahead = true;
            if ( token_IsSexp.token_type == "RIGHT-PAREN" || token_IsSexp.token_type == "DOT" ) {
              loop = false;
            } // if
          } // if
          else {
            NoAtomQuoteErrorInfo aNoAtomQuoteErrorInfo;    // return NoAtomQuoteErrorInfo
            aNoAtomQuoteErrorInfo.token_name = token_IsSexp.token_name;
            aNoAtomQuoteErrorInfo.column = token_IsSexp.token_column;
            aNoAtomQuoteErrorInfo.line = token_IsSexp.token_line;
            aScanner.ReadErrorLine();
            throw aNoAtomQuoteErrorInfo;
          } // else

        } // while

      } // if

      if ( token_IsSexp.token_type == "DOT" ) {
        mAccurate_token_vector.push_back( token_IsSexp );
        mlookahead = false;
        if ( IsSexp( token_IsSexp, aScanner ) ) {
          // 往下繼續做
        } // if
        else {
          NoAtomQuoteErrorInfo aNoAtomQuoteErrorInfo;     // return NoAtomQuoteErrorInfo
          aNoAtomQuoteErrorInfo.token_name = token_IsSexp.token_name;
          aNoAtomQuoteErrorInfo.column = token_IsSexp.token_column;
          aNoAtomQuoteErrorInfo.line = token_IsSexp.token_line;
          aScanner.ReadErrorLine();
          throw aNoAtomQuoteErrorInfo;
        } // else

      } // if

      if ( mlookahead == false ) {               // 針對"DOT"的處理，再繼續Peek下一個是不是')'。
        token_IsSexp = aScanner.PeekToken();    // 偷看下一個Token RIGHT-PAREN
        maPeekToken = token_IsSexp;              // 設定aPeekToken
        mlookahead = true;
      } // if

      if ( token_IsSexp.token_type == "RIGHT-PAREN" ) {
        mAccurate_token_vector.push_back( token_IsSexp );
        mlookahead = false;
        return true;
      } // if
      else {
        NoRightParenErrorInfo aNoRightParen;            // return NoRightParen
        aNoRightParen.token_name = token_IsSexp.token_name;
        aNoRightParen.column = token_IsSexp.token_column;
        aNoRightParen.line = token_IsSexp.token_line;
        aScanner.ReadErrorLine();
        throw aNoRightParen;
      } // else

    } // else if
    else if ( token_IsSexp.token_type == "QUOTE" ) {            // QUOTE <S-exp>
      if ( IsSexp( token_IsSexp, aScanner ) ) {
        return true;
      } // if
      else {
        NoAtomQuoteErrorInfo aNoAtomQuoteErrorInfo;
        aNoAtomQuoteErrorInfo.token_name = token_IsSexp.token_name;
        aNoAtomQuoteErrorInfo.column = token_IsSexp.token_column;
        aNoAtomQuoteErrorInfo.line = token_IsSexp.token_line;
        aScanner.ReadErrorLine();
        throw aNoAtomQuoteErrorInfo;
      } // else

    } // else if
    else {
      return false;
    } // else

    return false;
  } // IsSexp()

  bool IsAtom( TokenData token_IsAtom ) {
    if ( token_IsAtom.token_type == "SYMBOL" || token_IsAtom.token_type == "INT"
         || token_IsAtom.token_type == "FLOAT" || token_IsAtom.token_type == "STRING"
         || token_IsAtom.token_type == "NIL" || token_IsAtom.token_type == "LEFT-PAREN RIGHT-PAREN"
         || token_IsAtom.token_type == "T" ) {
      return true;
    } // if

    return false;
  } // IsAtom()

  void TranslateToken( queue<int> & dotforquote ) {      // 把輸入的sexp轉成dotted pair的形式。
    TokenData token_Dot_data;
    token_Dot_data.token_name = ".";
    token_Dot_data.token_type = "DOT";
    TokenData token_LP_data;
    token_LP_data.token_name = "(";
    token_LP_data.token_type = "LEFT-PAREN";
    TokenData token_RP_data;
    token_RP_data.token_name = ")";
    token_RP_data.token_type = "RIGHT-PAREN";
    TokenData token_NIL_data;
    token_NIL_data.token_name = "nil";
    token_NIL_data.token_type = "NIL";
    TokenData token_QUOTE_data;
    token_QUOTE_data.token_name = "quote";
    token_QUOTE_data.token_type = "QUOTE";
    int anumber = 0;
    int realnumber = 0; // 遇到下一個左括號之前所還沒處理的quote數目(要在右括號處理時新增.nil)
    stack<LPforRP> lpinfo; // 存與真實右括號相對應之真實左括號資訊
    if ( mAccurate_token_vector.size() == 1 ) {
      mTranslated_token_vector.push_back( mAccurate_token_vector[0] );   // ATOM
      return;
    } // if
    else {
      while ( mAccurate_token_vector.size() > anumber ) {
        if ( mAccurate_token_vector[anumber].token_type == "LEFT-PAREN" ) {    // 先記錄該子或父的sexp當中有幾個空白先

          int cur = mTranslated_token_vector.size() - 1;
          if ( cur != -1 ) {
            if ( mTranslated_token_vector[cur].token_type != "DOT"
                 && mTranslated_token_vector[cur].token_type != "LEFT-PAREN" ) {
              mTranslated_token_vector.push_back( token_Dot_data );
              mTranslated_token_vector.push_back( token_LP_data );
            } // if
          } // if

          mTranslated_token_vector.push_back( mAccurate_token_vector[anumber] );
          LPforRP newLPforRP;
          newLPforRP.real_num = 0;
          newLPforRP.real_num = newLPforRP.real_num + realnumber;
          lpinfo.push( newLPforRP );
          realnumber = 0;
          anumber++;

          if ( mAccurate_token_vector[anumber].token_type != "QUOTE"
               && mAccurate_token_vector[anumber].token_type != "LEFT-PAREN" ) {
            mTranslated_token_vector.push_back( mAccurate_token_vector[anumber] );    // 存(之後下一個sexp【不是(了】
            anumber++;
          } // if
          else if ( mAccurate_token_vector[anumber].token_type != "LEFT-PAREN" ) {
            mTranslated_token_vector.push_back( token_LP_data );                       // 先建一個(
            mTranslated_token_vector.push_back( token_QUOTE_data );
            realnumber++;
            anumber++;
          } // else

        } // if
        else if ( mAccurate_token_vector[anumber].token_type == "QUOTE" ) {
          int cur = mTranslated_token_vector.size() - 1;
          if ( cur != -1 ) {
            if ( mTranslated_token_vector[cur].token_type != "DOT" ) {
              mTranslated_token_vector.push_back( token_Dot_data );
            } // if

            mTranslated_token_vector.push_back( token_LP_data );
            mTranslated_token_vector.push_back( token_LP_data );                       // 先建一個(
            mTranslated_token_vector.push_back( token_QUOTE_data );                     // 並把Quote丟
          } // if
          else {
            mTranslated_token_vector.push_back( token_LP_data );                       // 先建一個(
            mTranslated_token_vector.push_back( token_QUOTE_data );                     // 並把Quote丟
          } // else

          anumber++;
          realnumber++;
        } // else if
        else if ( mAccurate_token_vector[anumber].token_type == "RIGHT-PAREN" ) {
          LPforRP aLPforRP;
          aLPforRP = lpinfo.top();
          aLPforRP.real_num = aLPforRP.real_num + realnumber;
          int cur = mTranslated_token_vector.size() - 1;
          if ( mTranslated_token_vector[cur-1].token_type == "LEFT-PAREN" ) {
            mTranslated_token_vector.push_back( token_Dot_data );
            mTranslated_token_vector.push_back( token_NIL_data );
          } // if
          else if ( mTranslated_token_vector[cur].token_type == "RIGHT-PAREN" ) {
            mTranslated_token_vector.push_back( token_Dot_data );
            mTranslated_token_vector.push_back( token_NIL_data );
          } // else if

          mTranslated_token_vector.push_back( mAccurate_token_vector[anumber] );
          while ( aLPforRP.real_num > 0 ) {
            mTranslated_token_vector.push_back( token_Dot_data );
            mTranslated_token_vector.push_back( token_NIL_data );
            mTranslated_token_vector.push_back( token_RP_data );
            aLPforRP.real_num--;
          } // while

          anumber++;
          lpinfo.pop();
          realnumber = 0;
        } // else if
        else if ( mAccurate_token_vector[anumber].token_type == "DOT" ) {
          mTranslated_token_vector.push_back( mAccurate_token_vector[anumber] );
          if ( mAccurate_token_vector[anumber+1].token_type == "QUOTE" ) {
            dotforquote.push( mTranslated_token_vector.size() );
          } // if
          anumber++;
        } // else if
        else {                   // 多增加一對.(
          int cur = mTranslated_token_vector.size() - 1;
          if ( mTranslated_token_vector[cur].token_type != "DOT"
               && mTranslated_token_vector[cur].token_type != "QUOTE" ) {
            mTranslated_token_vector.push_back( token_Dot_data );
            mTranslated_token_vector.push_back( token_LP_data );
            mTranslated_token_vector.push_back( mAccurate_token_vector[anumber] );
          } // if
          else if ( mTranslated_token_vector[cur].token_type == "QUOTE" ) {
            mTranslated_token_vector.push_back( token_Dot_data );
            mTranslated_token_vector.push_back( token_LP_data );
            mTranslated_token_vector.push_back( mAccurate_token_vector[anumber] );
            mTranslated_token_vector.push_back( token_Dot_data );
            mTranslated_token_vector.push_back( token_NIL_data );
            mTranslated_token_vector.push_back( token_RP_data );
            realnumber--;
            while ( realnumber > 0 ) {
              mTranslated_token_vector.push_back( token_Dot_data );
              mTranslated_token_vector.push_back( token_NIL_data );
              mTranslated_token_vector.push_back( token_RP_data );
              realnumber--;
            } // while

          } // else if
          else {
            mTranslated_token_vector.push_back( mAccurate_token_vector[anumber] );
          } // else

          anumber++;
        } // else

      } // while

    } // else

  } // TranslateToken()

  TreeNode * BuildTree( TreeNode * aTreeRoot, int & i, queue<int> dotforquote, int & record_pos ) {
    record_pos++;
    TreeNode * newnode;
    newnode = new TreeNode;
    if ( mTranslated_token_vector.size() <= i ) {
      return NULL;
    } // if
    else if ( mTranslated_token_vector[i].token_type == "DOT" ) {
      // 樹返回並往右邊走。
      return NULL;
    } // else if
    else {
      newnode -> right = NULL;
      newnode -> left = NULL;
      newnode -> isStart = false;
      newnode -> isEnd = false;
      newnode -> token_data = mTranslated_token_vector[i];
      if ( mTranslated_token_vector.size() == 1 ) return newnode;
      // 設定Sexp開始，(前一個沒.代表Start
      if ( i == 0 ) {
        newnode -> isStart = true;
      } // if
      else {
        if ( mTranslated_token_vector[i].token_type == "LEFT-PAREN"
             && mTranslated_token_vector[i-1].token_type != "DOT" ) {
          newnode -> isStart = true;
        } // if

      } // else

      if ( dotforquote.size() > 0 ) {
        int pos = dotforquote.front();
        if ( pos == record_pos ) {
          newnode -> isEnd = true;
          dotforquote.pop();
        } // if

      } // if

      i++;
      bool finished = false;
      // 預測下一個是不是)，是的話直接設為IsEnd並讀完所有)
      while ( mTranslated_token_vector[i].token_type == "RIGHT-PAREN" && !finished ) {
        newnode -> isEnd = true;
        i++;
        if ( mTranslated_token_vector.size() > i ) {
          if ( mTranslated_token_vector[i].token_type != "RIGHT-PAREN" ) {
            finished = true;
          } // if

        } // if
        else {
          return newnode;
        } // else

      } // while

      newnode -> left = BuildTree( newnode, i, dotforquote, record_pos );      // 做完一個子sexp(expr)之後
      if ( mTranslated_token_vector.size() <= i ) return newnode;
      if ( mTranslated_token_vector[i].token_type == "DOT" ) {
        i++;
        return newnode; // 遇到DOT中斷
      } // if

      newnode -> right = BuildTree( newnode, i, dotforquote, record_pos );
      return newnode;
    } // else

    return newnode;
  } // BuildTree()

  vector<TokenData> ReturnToken_vector() {
    return mAccurate_token_vector;
  } // ReturnToken_vector()

}; // Parser

class Tree {
  private:
  vector<TreeNode*> mAllFunPara;  // 所有存入的function & parameter，(存左括號連接點)。
  vector<SystemSymbol> mSystemSymbolTable;
  SaveFunctionParameter mSave_Table;
  TreeNode * mStart_ResultSExp;   // 開始的頭，此為結果。
  TreeNode * mCur_ResultSExp;    //  現在進行到的位置，多Function判斷用。
  bool mDoingQuote;          // 該sexp只有quote，計算多餘的第一個quote用。
  int mCurrent_pos;         // 每一次呼叫都增加1，因為要用此來插入mAllFunPara。
  int mLevel_num;
  // KEY:遇到QUOTE就是一個List，不然下一個Is_Start左邊接的就是function。
  TreeNode * EvaluateParameter( TreeNode * inputSExp ) {
    if ( inputSExp ) {
      if ( inputSExp -> isStart ) {  // 該層開始。他媽的要先收集左邊的function跟在右手邊的所有參數。
        // 儲存該function node isStart的位置。
        mLevel_num++;
        ReSetmSave_Table();
        mAllFunPara.push_back( inputSExp );         // *要做修改(紀錄node)*
        mSave_Table.fun_Pos = mCurrent_pos;         // *要做修改(紀錄fun位置)*
        mCurrent_pos++;
        EvaluateParameter( inputSExp -> right );
        //
        return CheckAllErrors_EVAFunction( mSave_Table );   // 開始做運算(開層開始計算。)
      } // if
      else if ( inputSExp -> isEnd ) {
        // 驗收時間!!! non-list的優先順序大於一切。先判斷有沒有non-list。
        NonList_Chcek( inputSExp, mSave_Table );
      } // else if
      else if ( inputSExp -> token_data.token_type == "LEFT-PAREN" ) {  // 遇到連接用的左括號。
        mSave_Table.argument_Num++;                                    // 左邊存的node要是參數()。
        // 儲存參數位置。
        mSave_Table.parameter_Pos.push( mCurrent_pos );       // 存該點位置
        mAllFunPara.push_back( inputSExp );
        mCurrent_pos++;
        EvaluateParameter( inputSExp -> right );
      } // else if

    } // if

    return NULL;
  } // EvaluateParameter()

  TreeNode * CheckAllErrors_EVAFunction( SaveFunctionParameter aSaveFunPara ) {
    int fun_pos = aSaveFunPara.fun_Pos;         // fun位置
    int argu_num = aSaveFunPara.argument_Num;   // argu數目
    TreeNode * fun_node = mAllFunPara[fun_pos] -> left; // 找到此function_node了
    if ( fun_node -> isStart ) {        // 如果又遇到左括號，就開始遞迴之旅，拿到我要的function node。
      fun_node = EvaluateParameter( fun_node );
    } // if

    // 再來檢查Function，最後檢查Argument Number。
    Function_Check( fun_node, aSaveFunPara.fun_Name, aSaveFunPara.fun_Type );
    ArgumentNum_Check( argu_num, aSaveFunPara.fun_Name, aSaveFunPara.fun_Type );
    return EvaluateFunction( aSaveFunPara );
  } // CheckAllErrors_EVAFunction()

  TreeNode * EvaluateFunction( SaveFunctionParameter aSaveFunPara ) {
    string fun_name = aSaveFunPara.fun_Name;
    string fun_type = aSaveFunPara.fun_Type;
    if ( fun_type == "Constructors" ) {
      if ( fun_name == "cons" ) return EVAcons( aSaveFunPara );
      else return EVAlist( aSaveFunPara );
    } // if
    else if ( fun_type == "Quote" ) {
      // 要passone quote，回傳參數。
      return EVAquote( aSaveFunPara );
    } // else if
    else if ( fun_type == "Part accessors" ) {
      if ( fun_name == "car" ) return EVAcar_cdr( "car", aSaveFunPara );
      else return EVAcar_cdr( "cdr", aSaveFunPara );
    } // else if
    else if ( fun_type == "Bounding" ) {
      EVAdefine( aSaveFunPara );
    } // else if
    else if ( fun_type == "Primitive predicates" ) {

    } // else if
    else if ( fun_type == "Number arithmetic" ) {

    } // else if
    else if ( fun_type == "Logical" ) {

    } // else if
    else if ( fun_type == "Number compare" ) {

    } // else if
    else if ( fun_type == "String compare" ) {

    } // else if
    else if ( fun_type == "Eqivalence tester" ) {

    } // else if
    else if ( fun_type == "Sequencing" ) {

    } // else if
    else if ( fun_type == "Conditionals" ) {

    } // else if

    return NULL;
  } // EvaluateFunction()

  // 參數有四種的可能，1.function 2.quote(變種)參數  3.sybol(變種define)參數 4.一般參數
  // 如果是function會回傳false，開始進入新的function計算。(當前後面的參數暫停計算)。
  TreeNode * DealParameterType( TreeNode * para_node, string & parameter_type ) {
    int define_pos = -1;
    if ( IsBoundSymbol( para_node -> token_data, define_pos ) ) {   // 先判斷式是不是SYMBOL
      TreeNode * new_eval_tree = NULL;
      para_node = Return_NewEval_Tree( gDefineTable[define_pos].define_value, new_eval_tree );
    } // if
    else {
      if ( para_node -> token_data.token_type == "SYMBOL" ) {
        UnboundSymbolErrorInfo aUnboundSymbolErrorInfo;
        aUnboundSymbolErrorInfo.symbol_name = para_node -> token_data.token_name;
        throw aUnboundSymbolErrorInfo;
      } // if
    } // else

    //  如果node的參數是開始且是unbound才可以進入新的function運算。
    if ( para_node -> isStart && define_pos == -1 ) {
      para_node = EvaluateParameter( para_node );
    } // if
    // 開始進行參數篩選。

    if ( mDoingQuote ) {
      parameter_type = "DoingQuote";
    } // if

    mDoingQuote = false;
    return para_node;
  } // DealParameterType()

  TreeNode * EVAcons( SaveFunctionParameter aSaveFunPara ) {
    int i = 0;
    string parameter_type = "Parameter";
    if ( mStart_ResultSExp == NULL ) {
      SetStartResult();
      aSaveFunPara.result_Node = mStart_ResultSExp;
      mCur_ResultSExp = aSaveFunPara.result_Node;
    } // if
    else {
      aSaveFunPara.result_Node = ReSetLinkResult();
    } // else

    while ( aSaveFunPara.argument_Num > i ) {
      int para_pos = aSaveFunPara.parameter_Pos.front();
      TreeNode * real_para = DealParameterType( mAllFunPara[para_pos] -> left, parameter_type );
      if ( i == 0 ) {
        aSaveFunPara.result_Node -> left = real_para;
        mCur_ResultSExp = aSaveFunPara.result_Node;
      } // if
      else {
        if ( parameter_type == "Parameter" ) {
          if ( real_para -> token_data.token_type == "LEFT-PAREN" ) {
            real_para -> isStart = false;
            real_para -> isEnd = false;
          } // if
          else {
            real_para -> isStart = false;
            real_para -> isEnd = true;
          } // else
        } // if
        else if ( parameter_type == "DoingQuote" ){

          if ( real_para -> left -> left -> token_data.token_type != "QUOTE" ){ //變成同階層，因左括號前為.
            real_para = real_para -> left;
            real_para -> isStart = false;
            real_para -> isEnd = false;
          } // if
          else {
            real_para -> isStart = false;
            real_para -> isEnd = true;
          } // else

        } // else if

        aSaveFunPara.result_Node -> right = real_para;
        mCur_ResultSExp = aSaveFunPara.result_Node -> right;
      } // else

      parameter_type = "Parameter";
      aSaveFunPara.parameter_Pos.pop();
      i++;
    } // while

    return aSaveFunPara.result_Node;
  } // EVAcons()

  TreeNode * EVAlist( SaveFunctionParameter aSaveFunPara ) {
    if ( aSaveFunPara.argument_Num == 0 ) {   // (list) 會return nil_node。
      mAllFunPara[aSaveFunPara.fun_Pos] -> right -> isEnd = false;
      return mAllFunPara[aSaveFunPara.fun_Pos] -> right;
    } // if

    int i = 0;
    string parameter_type = "Parameter";
    if ( mStart_ResultSExp == NULL ) {
      SetStartResult();
      aSaveFunPara.result_Node = mStart_ResultSExp;
      mCur_ResultSExp = aSaveFunPara.result_Node;
    } // if
    else {
      aSaveFunPara.result_Node = ReSetLinkResult();
    } // else

    TreeNode * cur_node = aSaveFunPara.result_Node;
    TreeNode * link_node;
    while ( aSaveFunPara.argument_Num > i ) {
      int para_pos = aSaveFunPara.parameter_Pos.front();
      TreeNode * real_para = DealParameterType( mAllFunPara[para_pos] -> left, parameter_type );
      if ( i == 0 ) {
        cur_node -> left = real_para;
        if ( aSaveFunPara.argument_Num == 1 ) cur_node -> right = mAllFunPara[para_pos] -> right;
      } // if
      else if ( aSaveFunPara.argument_Num == i + 1 ) {   // 哥哥到底了。
        if ( parameter_type == "Parameter" ) {
          link_node = ReSetLinkResult();
          cur_node -> right = link_node;
          cur_node = cur_node -> right;
          cur_node -> left = real_para;
          cur_node -> right = mAllFunPara[para_pos] -> right;
        } // if
        else {
          cur_node -> right = real_para;
        } // else

      } // else if
      else {    // 接左邊並設定新的node
        if ( parameter_type == "Parameter" ) {
          link_node = ReSetLinkResult();
          cur_node -> right = link_node;
          cur_node = cur_node -> right;
          cur_node -> left = real_para;
        } // if
        else {
          cur_node -> right = real_para;
          cur_node = cur_node -> right;
          cur_node -> right = NULL;
        } // else

      } // else

      mCur_ResultSExp = cur_node;
      parameter_type = "Parameter";
      aSaveFunPara.parameter_Pos.pop();
      i++;
    } // while

    return aSaveFunPara.result_Node;
  } // EVAlist()

  TreeNode * EVAquote( SaveFunctionParameter aSaveFunPara ) {
    // 回傳quote之夠的第一個參數。
    mLevel_num--;
    int para_pos = aSaveFunPara.parameter_Pos.front();
    if (  mAllFunPara[para_pos] -> left -> token_data.token_type != "LEFT-PAREN" ) {
      aSaveFunPara.result_Node = mAllFunPara[para_pos] -> left;
    } // if
    else if ( mCur_ResultSExp == NULL ) {
      aSaveFunPara.result_Node = mAllFunPara[para_pos] -> left;
      mDoingQuote = true;
    } // else if
    else if ( mCur_ResultSExp -> left == NULL && mCur_ResultSExp -> right == NULL ) {
      aSaveFunPara.result_Node = mAllFunPara[para_pos] -> left;
      mDoingQuote = true;
    } // else if
    else if ( mCur_ResultSExp -> left == NULL ) {
      aSaveFunPara.result_Node = mAllFunPara[para_pos] -> left;
      mDoingQuote = true;
    } // if
    else {
      aSaveFunPara.result_Node = mAllFunPara[para_pos];
      mDoingQuote = true;
    } // else

    return aSaveFunPara.result_Node;
  } // EVAQuote()

  void EVAdefine( SaveFunctionParameter aSaveFunPara ) {
    // 先檢查argument_num。
    bool define_error = false;
    int repeat_pos = -1, i = 0;
    int para_1_pos = aSaveFunPara.parameter_Pos.front();
    int para_2_pos = aSaveFunPara.parameter_Pos.back();
    TreeNode * para_1_node = mAllFunPara[para_1_pos] -> left;
    TreeNode * para_2_node = NULL;
    string symbol_name = para_1_node -> token_data.token_name;
    string symbol_type = para_1_node -> token_data.token_type;
    if ( aSaveFunPara.argument_Num != 2 ) {                         // 先檢查參數數目。
      define_error = true;
    } // if
    else if ( para_1_node -> token_data.token_type != "SYMBOL" ) {  // 再來檢查是不是系統的function。
      define_error = true;
    } // else if
    else if ( IsSystemSymbol( symbol_name, symbol_type ) ) {
      define_error = true;
    } // else if
    else {                                                          // 最後檢查其參數之間的關係。
      while ( gDefineTable.size() > i ) {         // 先檢查有沒有被定義過。
        if ( gDefineTable[i].define_name == symbol_name ) {
          repeat_pos = i;
        } // if

        i++;
      } // while

      string parameter_type = "Parameter";
      para_2_node = DealParameterType( mAllFunPara[para_2_pos] -> left, parameter_type ); //看有沒有被定義過
    } // else

    if ( define_error ) {
      FormatErrorInfo aFormatErrorInfo;
      int fun_pos = aSaveFunPara.fun_Pos;
      aFormatErrorInfo.format_error_node = mAllFunPara[fun_pos];
      aFormatErrorInfo.format_fun_name = "DEFINE";
      throw aFormatErrorInfo;
    } // if
    else {
      if ( repeat_pos == -1 ) {
        DefineTable aDefineTable;
        aDefineTable.define_name = symbol_name;
        TreeNode * new_define_node = NULL;
        new_define_node = Build_Define_Tree( para_2_node, new_define_node );
        aDefineTable.define_value =new_define_node;
        gDefineTable.push_back( aDefineTable );
      } // if
      else {
        TreeNode * new_define_node = NULL;
        new_define_node = Build_Define_Tree( para_2_node, new_define_node );
        gDefineTable[repeat_pos].define_value = new_define_node;
      } // else

      cout << symbol_name << " defined\n";
      mPrint_SExp = false;
    } // else

  } // EVAdefine()

  TreeNode * EVAcar_cdr( string fun_name, SaveFunctionParameter aSaveFunPara ) {
    string parameter_type = "Parameter";
    int para_pos = aSaveFunPara.parameter_Pos.front();
    TreeNode * part_access = DealParameterType( mAllFunPara[para_pos] -> left, parameter_type );

    // 檢查其part有無錯誤，錯誤就throw incorrect argument type的error。
    if ( part_access -> token_data.token_type != "LEFT-PAREN" ) {
      ArgumentTypeErrorInfo aArgumentTypeErrorInfo;
      aArgumentTypeErrorInfo.function_name = fun_name;
      aArgumentTypeErrorInfo.argumentype_error_name = part_access -> token_data.token_name;
      throw aArgumentTypeErrorInfo;
    } // if
    else if ( part_access -> left -> token_data.token_type == "QUOTE" ){
      ArgumentTypeErrorInfo aArgumentTypeErrorInfo;
      aArgumentTypeErrorInfo.function_name = fun_name;
      aArgumentTypeErrorInfo.argumentype_error_name = "\'";
      throw aArgumentTypeErrorInfo;
    } // else if

    TreeNode * left_part = part_access;
    TreeNode * right_part = part_access;
    // 開始做計算，確認是否找到了該層的參數才能運算。
    // (一) 先確定層數，再確定參數。
    if ( fun_name == "car" ) {
      left_part = left_part -> left;
      aSaveFunPara.result_Node = left_part;
    } // if
    else {
      if ( right_part -> left -> token_data.token_type == "LEFT-PAREN" ) {

      } // if
      else {    // 如果是第一層的狀況。
        right_part = right_part -> right;
        if ( right_part -> isEnd ) {
          right_part -> isEnd = false;
          right_part -> isStart = false;
        } // if
        else {
          right_part -> isEnd = false;
          right_part -> isStart = true;
        } // else

      } // else

      aSaveFunPara.result_Node = right_part;
    } // else

    return aSaveFunPara.result_Node;
  } // EVAcar_cdr()


  TreeNode * Build_Define_Tree( TreeNode * define_tree, TreeNode * new_define_tree ) {
    // 新建一個新的define空間在gDefineTable中。
    if ( define_tree ) {
      new_define_tree = new TreeNode;
      new_define_tree -> token_data = define_tree -> token_data;
      new_define_tree -> isStart = define_tree -> isStart;
      new_define_tree -> isEnd = define_tree -> isEnd;
      new_define_tree -> left = Build_Define_Tree( define_tree -> left, new_define_tree );
      new_define_tree -> right = Build_Define_Tree( define_tree -> right, new_define_tree );
      return new_define_tree;
    } // if

    return NULL;
  } // Build_Define_Tree()

  TreeNode * Return_NewEval_Tree( TreeNode * defined_tree, TreeNode * new_eval_tree ) {
    // return gDefineTable中的一個新的define空間給計算用的。
    if ( defined_tree ) {
      new_eval_tree = new TreeNode;
      new_eval_tree -> token_data =  defined_tree -> token_data;
      new_eval_tree -> isStart = defined_tree -> isStart;
      new_eval_tree -> isEnd = defined_tree -> isEnd;
      new_eval_tree -> left = Return_NewEval_Tree( defined_tree -> left, new_eval_tree );
      new_eval_tree -> right = Return_NewEval_Tree( defined_tree -> right, new_eval_tree );
      return new_eval_tree;
    } // if

    return NULL;
  } // Return_NewEval_Tree()

  // 檢查 -> Level與Argument number
  void ArgumentNum_Check( int argument_num, string fun_name, string fun_type ) {
    bool check_get = false;
    if ( fun_name == "cons" ) {
      if ( argument_num == 2 ) check_get = true;
    } // if
    else if ( fun_name == "list" ) {
      if ( argument_num >= 0 ) check_get = true;
    } // else if
    else if ( fun_name == "define" ) {
      if ( mLevel_num != 1 ) {
        LevelErrorInfo aLevelErrorInfo;
        aLevelErrorInfo.level_function_name = "DEFINE";
        throw aLevelErrorInfo;
      } // if

      check_get = true; // define有另外error的形式。 (一) define的level error (二) define的format error。
    } // else if
    else if ( fun_type == "Part accessors" ) {
      if ( argument_num == 1 ) check_get = true;
    } // else if
    else if ( fun_type == "Primitive predicates" ) {
      if ( argument_num == 1 ) check_get = true;
    } // else if
    else if ( fun_type == "Number arithmetic" ) {
      if ( argument_num >= 2 ) check_get = true;
    } // else if
    else if ( fun_type == "Logical" ) {
      if ( fun_name == "not" ) {
        if ( argument_num == 1 ) check_get = true;
      } // if
      else {
        if ( argument_num >= 2 ) check_get = true;
      } // else

    } // else if
    else if ( fun_type == "Number compare" || fun_type == "String compare" ) {
      if ( argument_num >= 2 ) check_get = true;
    } // else if
    else if ( fun_type == "Eqivalence tester" ) {
      if ( argument_num == 2 ) check_get = true;
    } // else if
    else if ( fun_type == "Sequencing" ) {
      if ( argument_num >= 1 ) check_get = true;
    } // else if
    else if ( fun_type == "Conditionals" ) {
      if ( fun_name == "cond" ) {
        if ( argument_num >= 1 ) check_get = true;
      } // if
      else {
        if ( argument_num == 2 || argument_num == 3 ) check_get = true;
      } // else

    } // else if
    else if ( fun_type == "Quote" ) {
      check_get = true;
    } // else if
    else if ( fun_type == "Special level" ) {
      if ( mLevel_num == 1 ) {
        if ( argument_num == 0 ) { // 實作 clean-environment
          check_get = true;
          mPrint_SExp = false;
          vector<DefineTable> newTable;
          gDefineTable = newTable; // 初始化DefineTable。
          cout << "environment cleaned" << "\n";
        } // if
      } // if
      else {        // level超過了，輸出level-error
        LevelErrorInfo aLevelErrorInfo;
        if ( fun_name == "exit" ) {
          aLevelErrorInfo.level_function_name = "EXIT";
        } // if
        else {
          aLevelErrorInfo.level_function_name = "CLEAN-ENVIRONMENT";
        } // else

        throw aLevelErrorInfo;
      } // else

    } // else if

    // throw argument_num error
    if ( check_get == false ) {  // 還有其他error的可能性。
      AgumentNumberErrorInfo aAgumentNumberErrorInfo;
      aAgumentNumberErrorInfo.fun_name = fun_name;
      throw aAgumentNumberErrorInfo;
    } // if

  } // ArgumentNum_Check()

  // (一)檢查 -> 有無此function  (二) 設定要進入此function的參數
  void Function_Check( TreeNode * fun_node, string & fun_name, string & fun_type ) {
    int define_pos = -1;  // 如果symbol有被定義的話，其值會被更改。
    if ( IsBoundSymbol( fun_node -> token_data, define_pos ) ) {  // 有被定義，不是的話代表是non
      fun_name = gDefineTable[define_pos].define_value -> token_data.token_name;
    } // if
    else {   // 沒被定義但有機會是以下的類型，不是的話1.symbol是unbound，2.不是symbol是nonfunction。
      fun_name = fun_node -> token_data.token_name;
    } // else

    if ( IsSystemSymbol( fun_name, fun_type ) ) {
      // 找到fun_name並設定fun_type，返回。
    } // if
    else {
      if ( define_pos == -1 ) { // 不是定義，如果是symbol就non-bound，如果不是symbol就nonfunction
        if ( fun_node -> token_data.token_type == "SYMBOL" ) {
          UnboundSymbolErrorInfo aUnboundSymbolErrorInfo;
          aUnboundSymbolErrorInfo.symbol_name = fun_node -> token_data.token_name;
          throw aUnboundSymbolErrorInfo;
        } // if
        else {
          NonFunctionErrorInfo aNonFunctionErrorInfo;
          aNonFunctionErrorInfo.nonfun_name = fun_node;
          throw aNonFunctionErrorInfo;
        } // else

      } // if
      else  {
        NonFunctionErrorInfo aNonFunctionErrorInfo;
        aNonFunctionErrorInfo.nonfun_name = gDefineTable[define_pos].define_value;
        throw aNonFunctionErrorInfo;
      } // else

    } // else

  } // Function_Check()

  // 檢查 -> 結束的node一定要是nil。
  void NonList_Chcek( TreeNode * cur_node, SaveFunctionParameter aSaveFunPara ) {
    int fun_pos = aSaveFunPara.fun_Pos;
    if ( cur_node -> token_data.token_type != "NIL" ) {  // throw nonlist(最後是.結束的)。
      NonListErrorInfo aNonListErrorInfo;
      aNonListErrorInfo.nonlist_node = mAllFunPara[fun_pos];
      throw aNonListErrorInfo;
    } // if

  } // NonList_Chcek()

  bool IsBoundSymbol( TokenData tokendata, int & define_pos ) {
    if ( tokendata.token_type == "SYMBOL" ) {
      int i = 0;
      while ( gDefineTable.size() > i ) {
        if ( gDefineTable[i].define_name == tokendata.token_name ) {
          define_pos = i;
          return true;
        } // if

        i++;
      } // while

    } // if

    return false;
  } // IsBoundSymbol

  // 一開始設定START_Resutlt的頭，
  void SetStartResult() {
    TokenData token_LP_data;
    token_LP_data.token_name = "(";
    token_LP_data.token_type = "LEFT-PAREN";
    mStart_ResultSExp = new TreeNode;
    mStart_ResultSExp -> token_data = token_LP_data;
    mStart_ResultSExp -> isStart = true;
    mStart_ResultSExp -> isEnd = false;
    mStart_ResultSExp -> left = NULL;
    mStart_ResultSExp -> right = NULL;
  } // SetStartResult()

  // 新增連接用(左括號)
  TreeNode * ReSetLinkResult() {
    TokenData token_LP_data;
    token_LP_data.token_name = "(";
    token_LP_data.token_type = "LEFT-PAREN";
    TreeNode * newnode;
    newnode = new TreeNode;
    newnode -> left = NULL;
    newnode -> right = NULL;
    if ( mCur_ResultSExp -> left == NULL ) {
      newnode -> token_data = token_LP_data;
      newnode -> isEnd = false;
      newnode -> isStart = true;
    } // if
    else if ( mCur_ResultSExp -> right == NULL ) {
      newnode -> token_data = token_LP_data;
      newnode -> isEnd = false;
      newnode -> isStart = false;
    } // else if

    return newnode;
  } // ReSetLinkResult()

  void ReSetmSave_Table() {
    mSave_Table.fun_Name = "";
    mSave_Table.fun_Type = "";
    mSave_Table.fun_Pos = -1;
    mSave_Table.argument_Num = 0;
    queue<int> newparameter_Pos;
    mSave_Table.parameter_Pos = newparameter_Pos;
    mSave_Table.result_Node = NULL;
  } // ReSetmSave_Table()

  public:
  bool mPrint_SExp;
  Tree( vector<SystemSymbol> aSystemSymbolTable ) {
    mDoingQuote = false;
    mCurrent_pos = 0;
    mStart_ResultSExp = NULL;
    mCur_ResultSExp = NULL;
    mLevel_num = 0;
    mPrint_SExp = true;
    vector<TreeNode*> aAllFunPara;
    mAllFunPara = aAllFunPara;
    mSystemSymbolTable = aSystemSymbolTable;
    ReSetmSave_Table();
  } // Tree()

  bool IsSystemSymbol( string & fun_name, string & fun_type ) {
    int i = 0;
    while ( mSystemSymbolTable.size() > i ) {
      if ( mSystemSymbolTable[i].symbol_name == fun_name ) {
        fun_type = mSystemSymbolTable[i].symbol_type;
        return true;
      } // if

      i++;
    } // while

    return false;
  } // IsSystemSymbol()

  // 印成list-like formate
  void PrintSExp( TreeNode * aTreeRoot, string & printed, bool & firstsexp ) {
    if ( aTreeRoot ) {
      if ( aTreeRoot -> isStart ) {
        if ( firstsexp ) {
          cout << aTreeRoot -> token_data.token_name + " ";
          printed = printed + "  ";
        } // if
        else {
          firstsexp = true;
          cout << printed;
          cout << aTreeRoot -> token_data.token_name + " ";
          printed = printed + "  ";
        } // else

      } // if
      else if ( aTreeRoot -> isEnd ) {
        // 如果是nil的話，表示該sexp沒有點，其他則代表有點。
        if ( aTreeRoot -> token_data.token_name == "nil" ) {
          printed = printed.assign( printed, 0, printed.size() - 2 );
          cout << printed << ")" << "\n";
        } // if
        else if ( aTreeRoot -> token_data.token_type == "LEFT-PAREN" ) {
          cout << printed;
          cout << "." << "\n";
          cout << printed;
          firstsexp = true;
        } // else if
        else {
          cout << printed;
          cout << "." << "\n";
          cout << printed;
          if ( aTreeRoot -> token_data.token_type == "FLOAT" ) {
            float pointnumber;
            pointnumber = atof( aTreeRoot -> token_data.token_name.c_str() );
            cout << fixed << setprecision( 3 ) << pointnumber << "\n";
          } // if
          else {
            cout << aTreeRoot -> token_data.token_name << "\n";
          } // else

          printed = printed.assign( printed, 0, printed.size() - 2 );
          cout << printed << ")" << "\n";
        } // else

      } // else if
      else if ( aTreeRoot -> left == NULL && aTreeRoot -> right == NULL ) {

        if ( firstsexp ) {
          firstsexp = false;
        } // if
        else {
          cout << printed;
        } // else

        if ( aTreeRoot -> token_data.token_type == "FLOAT" ) {
          float pointnumber;
          pointnumber = atof( aTreeRoot -> token_data.token_name.c_str() );
          cout << fixed << setprecision( 3 ) << pointnumber << "\n";
        } // if
        else {
          cout << aTreeRoot -> token_data.token_name << "\n";
        } // else
      } // else if

      PrintSExp( aTreeRoot -> left, printed, firstsexp );
      PrintSExp( aTreeRoot -> right, printed, firstsexp );
    } // if

  } // PrintSExp()

  void Preorder( TreeNode * aTreeRoot ) {
    if ( aTreeRoot ) {
      cout << aTreeRoot -> token_data.token_name;
      Preorder( aTreeRoot -> left );
      Preorder( aTreeRoot -> right );
    } // if
  } // Preorder()

  // catch Error跟進入運算，並返回運算完的reusltSExp給main()
  TreeNode * EvaluateSExp( TreeNode * inputSExp ) {
    try {
      if ( inputSExp -> left == NULL && inputSExp -> right == NULL ) {
        int define_pos = -1;
        if ( IsBoundSymbol( inputSExp -> token_data, define_pos ) ) {   // 先判斷式是不是SYMBOL
          TreeNode * new_eval_tree = NULL;
          mStart_ResultSExp = Return_NewEval_Tree( gDefineTable[define_pos].define_value, new_eval_tree );
        } // if
        else {
          if ( inputSExp -> token_data.token_type == "SYMBOL" ) {
            string none = "";
            if ( IsSystemSymbol( inputSExp -> token_data.token_name, none ) ) {
              ProcedureErrorInfo aProcedureErrorInfo;
              aProcedureErrorInfo.procedure_error_name = inputSExp -> token_data.token_name;
              throw aProcedureErrorInfo;
            } // if
            else {
              UnboundSymbolErrorInfo aUnboundSymbolErrorInfo;
              aUnboundSymbolErrorInfo.symbol_name = inputSExp -> token_data.token_name;
              throw aUnboundSymbolErrorInfo;
            } // else

          } // if
          else {
            mStart_ResultSExp = inputSExp;
          } // else

        } // else

      } // if
      else {
        return EvaluateParameter( inputSExp );  // 先計算參數，再計算function。
      } // else

    } // try
    catch( NonFunctionErrorInfo aNonFunctionErrorInfo ) {
      cout << "ERROR (attempt to apply non-function) : ";
      mStart_ResultSExp = aNonFunctionErrorInfo.nonfun_name;
    } // catch
    catch( UnboundSymbolErrorInfo aUnboundSymbolErrorInfo ) {
      cout << "ERROR (unbound symbol) : " << aUnboundSymbolErrorInfo.symbol_name << "\n";
      mPrint_SExp = false;
    } // catch
    catch( AgumentNumberErrorInfo aAgumentNumberErrorInfo ) {
      cout << "ERROR (incorrect number of arguments) : " << aAgumentNumberErrorInfo.fun_name << "\n";
      mPrint_SExp = false;
    } // catch
    catch( NonListErrorInfo aNonListErrorInfo ) {
      cout << "ERROR (non-list) : ";
      mStart_ResultSExp = aNonListErrorInfo.nonlist_node;
    } // catch
    catch( LevelErrorInfo aLevelErrorInfo ) {
      cout << "ERROR (level of " << aLevelErrorInfo.level_function_name << ")\n";
      mPrint_SExp = false;
    } // catch
    catch( FormatErrorInfo aFormatErrorInfo ) {
      cout << "ERROR (" << aFormatErrorInfo.format_fun_name << " format) : ";
      mStart_ResultSExp = aFormatErrorInfo.format_error_node;
    } // catch
    catch( ProcedureErrorInfo aProcedureErrorInfo ) {
      cout << "#<procedure " << aProcedureErrorInfo.procedure_error_name << ">\n";
      mPrint_SExp = false;
    } // catch
    catch( ArgumentTypeErrorInfo aArgumentTypeErrorInfo ) {
      cout << "ERROR (" << aArgumentTypeErrorInfo.function_name << " with incorrect argument type) : ";
      cout << aArgumentTypeErrorInfo.argumentype_error_name << "\n";
      mPrint_SExp = false;
    } // catch

    return mStart_ResultSExp;
  } // EvaluateSExp()

}; // Tree

vector<SystemSymbol> BuildSystemSymbol() {
  vector<SystemSymbol> aSystemSymbolTable;
  SystemSymbol aSystemSymbol;
  aSystemSymbol.symbol_name = "cons";
  aSystemSymbol.symbol_type = "Constructors";
  aSystemSymbolTable.push_back( aSystemSymbol );
  aSystemSymbol.symbol_name = "list";
  aSystemSymbolTable.push_back( aSystemSymbol );
  aSystemSymbol.symbol_name = "\'";
  aSystemSymbol.symbol_type = "Quote";
  aSystemSymbolTable.push_back( aSystemSymbol );
  aSystemSymbol.symbol_name = "quote";
  aSystemSymbolTable.push_back( aSystemSymbol );
  aSystemSymbol.symbol_name = "define";
  aSystemSymbol.symbol_type = "Bounding";
  aSystemSymbolTable.push_back( aSystemSymbol );
  aSystemSymbol.symbol_name = "car";
  aSystemSymbol.symbol_type = "Part accessors";
  aSystemSymbolTable.push_back( aSystemSymbol );
  aSystemSymbol.symbol_name = "cdr";
  aSystemSymbolTable.push_back( aSystemSymbol );
  aSystemSymbol.symbol_name = "atom?";
  aSystemSymbol.symbol_type = "Primitive predicates";
  aSystemSymbolTable.push_back( aSystemSymbol );
  aSystemSymbol.symbol_name = "pair?";
  aSystemSymbolTable.push_back( aSystemSymbol );
  aSystemSymbol.symbol_name = "list?";
  aSystemSymbolTable.push_back( aSystemSymbol );
  aSystemSymbol.symbol_name = "null?";
  aSystemSymbolTable.push_back( aSystemSymbol );
  aSystemSymbol.symbol_name = "integer?";
  aSystemSymbolTable.push_back( aSystemSymbol );
  aSystemSymbol.symbol_name = "real?";
  aSystemSymbolTable.push_back( aSystemSymbol );
  aSystemSymbol.symbol_name = "number?";
  aSystemSymbolTable.push_back( aSystemSymbol );
  aSystemSymbol.symbol_name = "string?";
  aSystemSymbolTable.push_back( aSystemSymbol );
  aSystemSymbol.symbol_name = "boolean?";
  aSystemSymbolTable.push_back( aSystemSymbol );
  aSystemSymbol.symbol_name = "symbol?";
  aSystemSymbolTable.push_back( aSystemSymbol );
  aSystemSymbol.symbol_name = "+";
  aSystemSymbol.symbol_type = "Number arithmetic";
  aSystemSymbolTable.push_back( aSystemSymbol );
  aSystemSymbol.symbol_name = "-";
  aSystemSymbolTable.push_back( aSystemSymbol );
  aSystemSymbol.symbol_name = "*";
  aSystemSymbolTable.push_back( aSystemSymbol );
  aSystemSymbol.symbol_name = "/";
  aSystemSymbolTable.push_back( aSystemSymbol );
  aSystemSymbol.symbol_name = "not";
  aSystemSymbol.symbol_type = "Logical";
  aSystemSymbolTable.push_back( aSystemSymbol );
  aSystemSymbol.symbol_name = "and";
  aSystemSymbolTable.push_back( aSystemSymbol );
  aSystemSymbol.symbol_name = "or";
  aSystemSymbolTable.push_back( aSystemSymbol );
  aSystemSymbol.symbol_name = ">";
  aSystemSymbol.symbol_type = "Number compare";
  aSystemSymbolTable.push_back( aSystemSymbol );
  aSystemSymbol.symbol_name = ">=";
  aSystemSymbolTable.push_back( aSystemSymbol );
  aSystemSymbol.symbol_name = "<";
  aSystemSymbolTable.push_back( aSystemSymbol );
  aSystemSymbol.symbol_name = "<=";
  aSystemSymbolTable.push_back( aSystemSymbol );
  aSystemSymbol.symbol_name = "=";
  aSystemSymbolTable.push_back( aSystemSymbol );
  aSystemSymbol.symbol_name = "string-append";
  aSystemSymbol.symbol_type = "String compare";
  aSystemSymbolTable.push_back( aSystemSymbol );
  aSystemSymbol.symbol_name = "string>?";
  aSystemSymbolTable.push_back( aSystemSymbol );
  aSystemSymbol.symbol_name = "string<?";
  aSystemSymbolTable.push_back( aSystemSymbol );
  aSystemSymbol.symbol_name = "string=?";
  aSystemSymbolTable.push_back( aSystemSymbol );
  aSystemSymbol.symbol_name = "eqv";
  aSystemSymbol.symbol_type = "Eqivalence tester";
  aSystemSymbolTable.push_back( aSystemSymbol );
  aSystemSymbol.symbol_name = "equal";
  aSystemSymbolTable.push_back( aSystemSymbol );
  aSystemSymbol.symbol_name = "begin";
  aSystemSymbol.symbol_type = "Sequencing";
  aSystemSymbolTable.push_back( aSystemSymbol );
  aSystemSymbol.symbol_name = "if";
  aSystemSymbol.symbol_type = "Conditionals";
  aSystemSymbolTable.push_back( aSystemSymbol );
  aSystemSymbol.symbol_name = "cond";
  aSystemSymbolTable.push_back( aSystemSymbol );
  aSystemSymbol.symbol_name = "exit";
  aSystemSymbol.symbol_type = "Special level";
  aSystemSymbolTable.push_back( aSystemSymbol );
  aSystemSymbol.symbol_name = "clean-environment";
  aSystemSymbolTable.push_back( aSystemSymbol );
  return aSystemSymbolTable;
} // BuildSystemSymbol()

// Scanner與Parser互相溝通的function，等Paser處理完並無錯之後就開始建Tree。
TreeNode * ReadSExp( TreeNode * aTreeRoot, int & lastspace, bool & finished_exit  ) {
  Scanner aScanner( lastspace );                // 創一個aScanner方便我們「切」此SExp。
  Parser aParser;                 // 創一個aParser檢查我們aScanner切出來的token，
  TokenData first_Token_Data;    // 文法有沒有正確，正確就bulidtree，錯誤就回傳錯誤。
  if ( aParser.IsSexp( first_Token_Data, aScanner ) ) {   // 判斷Sexp的合法性，並且如果該完成的Sexp後面沒東西讀掉。
    lastspace = aScanner.ReadEndLine();
  } // if
  else {
    NoAtomQuoteErrorInfo aNoAtomQuoteErrorInfo;          // 如果第一個SExp就出錯。
    aNoAtomQuoteErrorInfo.token_name = first_Token_Data.token_name;
    aNoAtomQuoteErrorInfo.column = first_Token_Data.token_column;
    aNoAtomQuoteErrorInfo.line = first_Token_Data.token_line;
    aScanner.ReadErrorLine();
    throw aNoAtomQuoteErrorInfo;
  } // else

  vector<TokenData> returnToken_vector = aParser.ReturnToken_vector(); // Sexp合法的開始。
  if ( returnToken_vector.size() == 3 ) {
    if ( returnToken_vector[0].token_name == "("
         && returnToken_vector[1].token_name == "exit"
         && returnToken_vector[2].token_name == ")" ) {
      finished_exit = true;
      return aTreeRoot;
    } // if

  } // if

  int i = 0, record_pos = -1;
  queue<int> dotforquote;
  aParser.TranslateToken( dotforquote );
  // aParser.PrintVector();
  aTreeRoot = aParser.BuildTree( aTreeRoot, i, dotforquote, record_pos );
  return aTreeRoot;
} // ReadSExp()

int main() {
  char linenter = '\0';
  scanf( "%d%c", &utestNum, &linenter );  // 讀取一個testnum和一個line-enter。
  cout << "Welcome to OurScheme!\n\n";
  cout << "> ";
  bool finished = false;
  int lastspace = 0;
  if ( cin.peek() == EOF ) {            // 先確定一開始測試檔中有資料，無就直接印錯誤，有就繼續往下走。
    cout << "ERROR (no more input) : END-OF-FILE encountered";
  } // if

  vector<SystemSymbol> systemSymbolTable;
  systemSymbolTable = BuildSystemSymbol();
  while ( !finished ) {
    TreeNode * inputSExp;               // 一次處理一個SExp，一個SExp代表一個樹的結構。
    inputSExp = new TreeNode;
    inputSExp -> left = NULL;
    inputSExp -> right = NULL;
    inputSExp -> isStart = false;
    inputSExp -> isEnd = false;
    try {
      inputSExp = ReadSExp( inputSExp, lastspace, finished );
      // aTree.Preorder( aTreeRoot );
      // Scanner與Paser互相溝通的function，等Paser處理完並無錯之後就開始建Tree。 user讀到 (exit)，設定finished，結束這次測試檔。
      if ( !finished ) {
        Tree aTree( systemSymbolTable );
        TreeNode * resultSExp;            // 一次處理一個SExp，一個SExp代表一個樹的結構。
        resultSExp = aTree.EvaluateSExp( inputSExp );
        bool firstsexp = true;
        string printed = "";
        // aTree.Preorder( resultSExp );
        if ( aTree.mPrint_SExp ) aTree.PrintSExp( resultSExp, printed, firstsexp );
      } // if

    } // try
    catch( int endoffile ) {         // error1(int): no more input。
      cout << "ERROR (no more input) : END-OF-FILE encountered";
      finished = true;
      lastspace = 0;
    } // catch
    catch( StringErrorInfo aStringErrorInfo ) {   // error2: scanner處理string的時候，有可能no closing quote
      cout << "ERROR (no closing quote) : END-OF-LINE encountered at Line "
           << aStringErrorInfo.line << " Column " << aStringErrorInfo.column << "\n";
      lastspace = 0;
    } // catch
    catch( NoAtomQuoteErrorInfo aNoAtomQuoteErrorInfo ) {
      cout << "ERROR (unexpected token) : atom or '(' expected when token at Line "
           << aNoAtomQuoteErrorInfo.line;
      cout << " Column " << aNoAtomQuoteErrorInfo.column << " is >>"
           << aNoAtomQuoteErrorInfo.token_name << "<<\n";
      lastspace = 0;
    } // catch
    catch( NoRightParenErrorInfo aNoRightParen ) {
      cout << "ERROR (unexpected token) : ')' expected when token at Line " << aNoRightParen.line;
      cout << " Column " << aNoRightParen.column << " is >>" << aNoRightParen.token_name << "<<\n";
      lastspace = 0;
    } // catch

    if ( !finished ) {
      cout << "\n";
      cout << "> ";
    } // if

  } // while

  cout << "\n";
  cout << "Thanks for using OurScheme!";
} // main()
